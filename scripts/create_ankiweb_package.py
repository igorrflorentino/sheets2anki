#!/usr/bin/env python3
"""
AnkiWeb Preparation Script

This script prepares the Sheets2Anki add-on for publication on AnkiWeb,
creating a clean and optimized package.
"""

import os
import shutil
import json
import zipfile
from pathlib import Path

def create_ankiweb_package():
    """Creates optimized package for AnkiWeb"""
    
    print("üì¶ PREPARING PACKAGE FOR ANKIWEB")
    print("=" * 50)
    
    # Directories
    script_dir = Path(__file__).parent
    source_dir = script_dir.parent  # Project root directory
    build_dir = source_dir / "build"
    package_dir = build_dir / "sheets2anki"
    
    # Clean previous build
    if build_dir.exists():
        shutil.rmtree(build_dir)
    
    # Create directories
    build_dir.mkdir()
    package_dir.mkdir()
    
    print("1. Copying essential files...")
    
    # Mandatory files
    essential_files = [
        "__init__.py",
        "manifest.json", 
        "config.json"
    ]
    
    for file in essential_files:
        source = source_dir / file
        dest = package_dir / file
        if source.exists():
            shutil.copy2(source, dest)
            print(f"   ‚úì {file}")
        else:
            print(f"   ‚ùå {file} not found")
    
    print("\n2. Copying source code...")
    
    # src directory
    src_source = source_dir / "src"
    src_dest = package_dir / "src"
    if src_source.exists():
        shutil.copytree(src_source, src_dest, ignore=ignore_patterns)
        print("   ‚úì src/")
    
    # libs directory
    libs_source = source_dir / "libs"
    libs_dest = package_dir / "libs"
    if libs_source.exists():
        shutil.copytree(libs_source, libs_dest, ignore=ignore_patterns)
        print("   ‚úì libs/")
    
    print("\n3. Configuring production mode...")
    
    # Change IS_DEVELOPMENT_MODE constant to False
    constants_path = package_dir / "src" / "constants.py"
    if constants_path.exists():
        with open(constants_path, 'r', encoding='utf-8') as f:
            constants_content = f.read()
        
        # Replace IS_DEVELOPMENT_MODE = True with IS_DEVELOPMENT_MODE = False
        constants_content = constants_content.replace(
            "IS_DEVELOPMENT_MODE = True", 
            "IS_DEVELOPMENT_MODE = False"
        )
        
        with open(constants_path, 'w', encoding='utf-8') as f:
            f.write(constants_content)
        
        print("   ‚úÖ Development mode disabled")
    
    print("\n4. Cleaning unnecessary files...")
    
    # Remove meta.json if it exists (automatically generated by Anki)
    meta_json_path = package_dir / "meta.json"
    if meta_json_path.exists():
        meta_json_path.unlink()
        print("   üóëÔ∏è  Removed: meta.json (automatically generated by Anki)")
    
    # Remove cache and development files
    for root, dirs, files in os.walk(package_dir):
        # Remove __pycache__ - CRITICAL for AnkiWeb
        dirs_to_remove = [d for d in dirs if d == "__pycache__"]
        for d in dirs_to_remove:
            shutil.rmtree(os.path.join(root, d))
            print(f"   üóëÔ∏è  Removed: {os.path.relpath(os.path.join(root, d), package_dir)}/__pycache__")
            dirs.remove(d)  # Prevents os.walk from entering the removed directory
        
        # Remove .pyc, .pyo files - CRITICAL for AnkiWeb
        for file in files[:]:  # Create list copy for safe iteration
            if file.endswith(('.pyc', '.pyo')):
                file_path = os.path.join(root, file)
                os.remove(file_path)
                print(f"   üóëÔ∏è  Removed: {os.path.relpath(file_path, package_dir)}")
        
        # Remove other unnecessary files
        for file in files[:]:
            if file.startswith('.DS_Store') or file.endswith('.tmp'):
                file_path = os.path.join(root, file)
                os.remove(file_path)
                print(f"   üóëÔ∏è  Removed: {os.path.relpath(file_path, package_dir)}")
    
    # Final check: ensure no __pycache__ or .pyc
    cache_found = False
    for root, dirs, files in os.walk(package_dir):
        if "__pycache__" in dirs:
            print(f"   ‚ùå ERROR: __pycache__ still present in {root}")
            cache_found = True
        for file in files:
            if file.endswith(('.pyc', '.pyo')):
                print(f"   ‚ùå ERROR: .pyc/.pyo file still present: {file}")
                cache_found = True
    
    if cache_found:
        print("   ‚ùå CRITICAL ERROR: AnkiWeb does not accept files with __pycache__ or .pyc!")
        return False
    else:
        print("   ‚úÖ Cleanup verification: OK (no __pycache__ or .pyc)")
    
    print("\n5. Validating package...")
    
    # Check mandatory files
    required = ["__init__.py", "manifest.json"]
    for req in required:
        if not (package_dir / req).exists():
            print(f"   ‚ùå ERROR: {req} not found in package!")
            return False
        else:
            print(f"   ‚úì {req}")
    
    # Check and validate manifest.json
    print("\nüîç Validating manifest.json...")
    manifest_valid, manifest = validate_manifest(package_dir / "manifest.json")
    if not manifest_valid:
        print("   ‚ùå ERROR: manifest.json does not comply with AnkiWeb specifications!")
        return False
    else:
        print("   ‚úÖ manifest.json validated successfully")
    
    print("\n6. Creating .ankiaddon file...")
    
    # Create .ankiaddon file for AnkiWeb
    # IMPORTANT: Follow AnkiWeb specifications - no root folder in ZIP
    ankiaddon_path = build_dir / "sheets2anki.ankiaddon"
    
    with zipfile.ZipFile(ankiaddon_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, dirs, files in os.walk(package_dir):
            for file in files:
                file_path = os.path.join(root, file)
                # CRITICAL: Relative path without the root folder (package_dir)
                # AnkiWeb requires files to be at the ZIP root
                arc_path = os.path.relpath(file_path, package_dir)
                zipf.write(file_path, arc_path)
                print(f"   üìù Added to ZIP: {arc_path}")
                
    print(f"   ‚úÖ Created: {ankiaddon_path}")
    
    # Verify created ZIP structure
    print("\n7. Verifying .ankiaddon file structure...")
    with zipfile.ZipFile(ankiaddon_path, 'r') as zipf:
        zip_contents = zipf.namelist()
        
        # Check if there's a root folder (should not have one)
        has_root_folder = any('/' not in name and name.endswith('/') for name in zip_contents if name != '')
        if has_root_folder:
            print("   ‚ùå ERROR: ZIP contains root folder - AnkiWeb does not accept!")
            return False
        
        # Check mandatory files at root
        root_files = [name for name in zip_contents if '/' not in name and name != '']
        if '__init__.py' not in root_files:
            print("   ‚ùå ERROR: __init__.py is not at the ZIP root!")
            return False
        if 'manifest.json' not in root_files:
            print("   ‚ùå ERROR: manifest.json is not at the ZIP root!")
            return False
            
        print("   ‚úÖ ZIP structure: OK")
        print(f"   üìÅ Files at root: {', '.join(root_files)}")
        
        # Check if there's __pycache__ or .pyc in ZIP
        cache_in_zip = [name for name in zip_contents if '__pycache__' in name or name.endswith(('.pyc', '.pyo'))]
        if cache_in_zip:
            print(f"   ‚ùå CRITICAL ERROR: Python cache in ZIP: {cache_in_zip}")
            print("   ‚ùå AnkiWeb does not accept files with __pycache__ or .pyc!")
            return False
        else:
            print("   ‚úÖ ZIP cache verification: OK")
    
    # Final statistics
    file_count = sum(len(files) for _, _, files in os.walk(package_dir))
    ankiaddon_size = ankiaddon_path.stat().st_size / 1024  # KB
    
    print(f"\nüìä PACKAGE STATISTICS:")
    print(f"   üìÅ Files included: {file_count}")
    print(f"   üì¶ .ankiaddon size: {ankiaddon_size:.1f} KB")
    if manifest:
        print(f"   üéØ Compatibility: Anki {manifest.get('min_point_version', 'N/A')} - {manifest.get('max_point_version', 'N/A')}")
    else:
        print(f"   üéØ Compatibility: Anki N/A - N/A")
    
    print(f"\n‚úÖ PACKAGE CREATED SUCCESSFULLY!")
    print(f"üìç File for AnkiWeb: {ankiaddon_path}")
    print(f"\nüìã NEXT STEPS FOR PUBLICATION:")
    print("   1. Access: https://ankiweb.net/shared/addons/")
    print("   2. Click 'Upload' or 'Share a New Add-on'")
    print(f"   3. Upload the file: {ankiaddon_path.name}")
    print("   4. Fill in additional add-on information")
    print("   5. Publish!")
    print(f"\n‚ö†Ô∏è  IMPORTANT:")
    print("   - The file is ready for AnkiWeb (no root folder)")
    print("   - All __pycache__ and .pyc files were removed")
    print("   - Structure follows AnkiWeb specifications")
    
    return True

def ignore_patterns(dir, files):
    """File patterns to ignore"""
    ignore = []
    for file in files:
        if file.startswith('.'):
            ignore.append(file)
        elif file.endswith(('.pyc', '.pyo')):
            ignore.append(file)
        elif file == '__pycache__':
            ignore.append(file)
    return ignore

def validate_manifest(manifest_path):
    """
    Validates manifest.json according to AnkiWeb specifications.
    
    For AnkiWeb, the manifest must contain at least:
    - package: specifies the folder name where the add-on will be stored
    - name: specifies the name shown to the user
    - conflicts (optional): list of other conflicting packages
    - mod (optional): timestamp of when the add-on was updated
    """
    try:
        with open(manifest_path, 'r', encoding='utf-8') as f:
            manifest = json.load(f)
    except Exception as e:
        print(f"   ‚ùå Error reading manifest.json: {e}")
        return False, None
    
    # Mandatory fields for AnkiWeb
    required_fields = ['package', 'name']
    
    for field in required_fields:
        if field not in manifest:
            print(f"   ‚ùå Mandatory field missing in manifest: {field}")
            return False, None
        if not manifest[field] or not isinstance(manifest[field], str):
            print(f"   ‚ùå Field '{field}' must be a non-empty string")
            return False, None
    
    # Validate 'conflicts' field if present
    if 'conflicts' in manifest:
        if not isinstance(manifest['conflicts'], list):
            print("   ‚ùå Field 'conflicts' must be a list")
            return False, None
        print(f"   ‚úì Conflicts declared: {len(manifest['conflicts'])} packages")
    
    # Validate 'mod' field if present
    if 'mod' in manifest:
        if not isinstance(manifest['mod'], (int, float)):
            print("   ‚ùå Field 'mod' must be a number (timestamp)")
            return False, None
    
    # Validate other useful fields
    optional_fields = ['version', 'author', 'description', 'homepage', 'min_point_version', 'max_point_version']
    for field in optional_fields:
        if field in manifest and manifest[field]:
            if field in ['min_point_version', 'max_point_version']:
                if not isinstance(manifest[field], int):
                    print(f"   ‚ö†Ô∏è  Field '{field}' should be an integer")
            print(f"   ‚úì {field}: {manifest[field]}")
    
    return True, manifest

if __name__ == "__main__":
    create_ankiweb_package()
