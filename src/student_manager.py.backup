"""
Gerenciamento de sele√ß√£o de alunos para o addon Sheets2Anki.

Este m√≥dulo implementa funcionalidades para permitir ao usu√°rio selecionar
quais alunos ele deseja sincroniz              if alunos_field:
            # Separar m√∫ltiplos alunos por v√≠rgula, ponto e v√≠rgula ou pipe
            alunos_list = re.split(r'[,;|]', alunos_field)
            for aluno in alunos_list: if alunos_field:
            # Separar m√∫ltiplos alunos por v√≠rgula, ponto e v√≠rgula ou pipe
            alunos_list = re.split(r'[,;|]', alunos_field)
            for aluno in alunos_list: if alunos_field:
            # Separar m√∫ltiplos alunos por v√≠rgula, ponto e v√≠rgula ou pipe
            alunos_list = re.split(r'[,;|]', alunos_field)
            for aluno in alunos_list: gerenciar a estrutura de subdecks por aluno.

Funcionalidades principais:
- Extra√ß√£o de alunos √∫nicos das planilhas
- Interface para sele√ß√£o de alunos
- Filtramento de notas por alunos selecionados
- Cria√ß√£o de subdecks hier√°rquicos por aluno
- Remo√ß√£o de notas de alunos desmarcados
"""

import re
from typing import Dict
from typing import List
from typing import Optional
from typing import Set

from . import templates_and_definitions as cols
from .compat import ButtonBox_Cancel
from .compat import ButtonBox_Ok
from .compat import DialogAccepted
from .compat import QCheckBox
from .compat import QDialog
from .compat import QDialogButtonBox
from .compat import QHBoxLayout
from .compat import QLabel
from .compat import QPushButton
from .compat import QScrollArea
from .compat import QTextEdit
from .compat import QVBoxLayout
from .compat import QWidget
from .compat import mw
from .compat import safe_exec_dialog
from .compat import showInfo
from .config_manager import get_enabled_students
from .config_manager import get_meta
from .config_manager import is_student_filter_active
from .config_manager import save_meta


def get_students_to_sync(all_students: Set[str]) -> Set[str]:
    """
    Obt√©m os alunos que devem ser sincronizados baseado na configura√ß√£o global.
    NOVA VERS√ÉO: Usa normaliza√ß√£o consistente de nomes.

    Args:
        all_students (Set[str]): Todos os alunos encontrados na planilha (j√° normalizados)

    Returns:
        Set[str]: Alunos que devem ser sincronizados (nomes normalizados)
    """
    # Verificar se o filtro est√° ativo (baseado na lista de alunos habilitados)
    if not is_student_filter_active():
        # Filtro inativo - sincronizar todos (j√° normalizados)
        return all_students

    # Obter alunos habilitados globalmente (case-sensitive)
    enabled_students_raw = get_enabled_students()
    enabled_students_set = {
        student for student in enabled_students_raw if student and student.strip()
    }

    # Se n√£o h√° alunos configurados, n√£o sincronizar nenhum
    if not enabled_students_set:
        return set()

    # Interse√ß√£o case-sensitive
    matched_students = all_students.intersection(enabled_students_set)

    print("üîç SYNC: Filtro de alunos aplicado:")
    print(f"  ‚Ä¢ Alunos na planilha: {sorted(all_students)}")
    print(f"  ‚Ä¢ Alunos habilitados: {sorted(enabled_students_set)}")
    print(f"  ‚Ä¢ Alunos para sync: {sorted(matched_students)}")

    return matched_students


class StudentSelectionDialog(QDialog):
    """
    Dialog para sele√ß√£o de alunos que o usu√°rio deseja sincronizar.
    """

    def __init__(self, students: List[str], deck_url: str, current_selection: Set[str]):
        super().__init__()
        self.students = sorted(students)  # Ordenar alfabeticamente
        self.deck_url = deck_url
        self.current_selection = current_selection.copy()
        self.checkboxes = {}

        self.setWindowTitle("Sele√ß√£o de Alunos - Sheets2Anki")
        self.setMinimumSize(500, 400)
        self.resize(600, 500)

        self._setup_ui()

    def _setup_ui(self):
        """Configura a interface do usu√°rio."""
        layout = QVBoxLayout()

        # T√≠tulo e explica√ß√£o
        title_label = QLabel("Selecione os alunos que deseja sincronizar:")
        title_label.setStyleSheet(
            "font-weight: bold; font-size: 12px; margin-bottom: 10px;"
        )
        layout.addWidget(title_label)

        info_text = QTextEdit()
        info_text.setPlainText(
            "‚Ä¢ Alunos selecionados ter√£o suas notas sincronizadas em subdecks separados\n"
            "‚Ä¢ Alunos desmarcados ter√£o suas notas removidas dos decks locais\n"
            "‚Ä¢ A estrutura ser√°: Deck Raiz::Deck Remoto::Aluno::Import√¢ncia::T√≥pico::Subt√≥pico::Conceito\n"
            "‚Ä¢ Cada aluno ter√° seu pr√≥prio Note Type personalizado"
        )
        info_text.setMaximumHeight(80)
        info_text.setStyleSheet(
            "background-color: #f0f0f0; border: 1px solid #ccc; padding: 5px;"
        )
        layout.addWidget(info_text)

        # Bot√µes de sele√ß√£o r√°pida
        quick_select_layout = QHBoxLayout()
        select_all_btn = QPushButton("Selecionar Todos")
        select_all_btn.clicked.connect(self._select_all)
        select_none_btn = QPushButton("Desmarcar Todos")
        select_none_btn.clicked.connect(self._select_none)

        quick_select_layout.addWidget(select_all_btn)
        quick_select_layout.addWidget(select_none_btn)
        quick_select_layout.addStretch()

        layout.addLayout(quick_select_layout)

        # √Årea de scroll para os checkboxes
        scroll_area = QScrollArea()
        scroll_widget = QWidget()
        scroll_layout = QVBoxLayout()

        # Criar checkboxes para cada aluno
        for student in self.students:
            checkbox = QCheckBox(student)
            checkbox.setChecked(student in self.current_selection)
            self.checkboxes[student] = checkbox
            scroll_layout.addWidget(checkbox)

        scroll_widget.setLayout(scroll_layout)
        scroll_area.setWidget(scroll_widget)
        scroll_area.setWidgetResizable(True)

        layout.addWidget(scroll_area)

        # Bot√µes de a√ß√£o
        button_box = QDialogButtonBox(ButtonBox_Ok | ButtonBox_Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)

        layout.addWidget(button_box)

        self.setLayout(layout)

    def _select_all(self):
        """Seleciona todos os alunos."""
        for checkbox in self.checkboxes.values():
            checkbox.setChecked(True)

    def _select_none(self):
        """Desmarca todos os alunos."""
        for checkbox in self.checkboxes.values():
            checkbox.setChecked(False)

    def get_selected_students(self) -> Set[str]:
        """Retorna o conjunto de alunos selecionados."""
        selected = set()
        for student, checkbox in self.checkboxes.items():
            if checkbox.isChecked():
                selected.add(student)
        return selected


def extract_students_from_remote_data(remote_deck) -> Set[str]:
    """
    Extrai todos os alunos √∫nicos presentes nos dados remotos.

    L√ìGICA REFATORADA:
    - Usa a nova estrutura RemoteDeck.notes
    - Extrai alunos da coluna ALUNOS de cada nota
    - Retorna conjunto com nomes case-sensitive

    Args:
        remote_deck: Objeto RemoteDeck com os dados da planilha

    Returns:
        Set[str]: Conjunto de alunos √∫nicos encontrados
    """
    students = set()

    if not hasattr(remote_deck, "notes") or not remote_deck.notes:
        return students

    for note_data in remote_deck.notes:
        alunos_field = note_data.get(cols.ALUNOS, "").strip()

        if alunos_field:
            # Separar m√∫ltiplos alunos por v√≠rgula
            alunos_list = [s.strip() for s in alunos_field.split(",") if s.strip()]
            for aluno in alunos_list:
                if aluno:
                    # Adicionar nome do estudante (case-sensitive)
                    students.add(aluno)

    return students


def get_selected_students_for_deck(deck_url: str) -> Set[str]:
    """
    Obt√©m os alunos selecionados para um deck espec√≠fico.
    Se n√£o houver sele√ß√£o espec√≠fica para o deck, usa a configura√ß√£o global.
    
    IMPORTANTE: Inclui [MISSING A.] se a funcionalidade estiver ativada.

    Args:
        deck_url: URL do deck remoto

    Returns:
        Set[str]: Conjunto de alunos selecionados para este deck (incluindo [MISSING A.] se aplic√°vel)
    """
    from .config_manager import get_deck_id
    from .config_manager import get_enabled_students
    from .config_manager import is_sync_missing_students_notes

    meta = get_meta()

    # Navegar pela estrutura: decks -> spreadsheet_id -> student_selection
    spreadsheet_id = get_deck_id(deck_url)
    deck_config = meta.get("decks", {}).get(spreadsheet_id, {})
    student_selection = deck_config.get("student_selection")

    # Se n√£o h√° sele√ß√£o espec√≠fica para o deck, usar configura√ß√£o global
    if student_selection is None:
        global_enabled = get_enabled_students()
        selected_students = set(global_enabled) if global_enabled else set()
    else:
        # Converter para set se for lista
        if isinstance(student_selection, list):
            selected_students = set(student_selection)
        else:
            selected_students = student_selection if isinstance(student_selection, set) else set()

    # NOVO: Incluir [MISSING A.] se a funcionalidade estiver ativada
    if is_sync_missing_students_notes():
        selected_students.add("[MISSING A.]")

    return selected_students


def save_selected_students_for_deck(deck_url: str, selected_students: Set[str]):
    """
    Salva a sele√ß√£o de alunos para um deck espec√≠fico.

    Args:
        deck_url: URL do deck remoto
        selected_students: Conjunto de alunos selecionados
    """
    from .config_manager import get_deck_id

    meta = get_meta()

    # Garantir estrutura do meta
    if "decks" not in meta:
        meta["decks"] = {}

    spreadsheet_id = get_deck_id(deck_url)
    if spreadsheet_id not in meta["decks"]:
        meta["decks"][spreadsheet_id] = {}

    # Converter set para lista para serializa√ß√£o JSON
    meta["decks"][spreadsheet_id]["student_selection"] = list(selected_students)

    save_meta(meta)


def show_student_selection_dialog(
    deck_url: str, available_students: Set[str]
) -> Optional[Set[str]]:
    """
    Mostra o dialog de sele√ß√£o de alunos e retorna a sele√ß√£o do usu√°rio.

    Args:
        deck_url: URL do deck remoto
        available_students: Conjunto de alunos dispon√≠veis na planilha

    Returns:
        Optional[Set[str]]: Conjunto de alunos selecionados ou None se cancelado
    """
    if not available_students:
        showInfo("N√£o foram encontrados alunos na coluna ALUNOS da planilha.")
        return None

    current_selection = get_selected_students_for_deck(deck_url)

    dialog = StudentSelectionDialog(
        list(available_students), deck_url, current_selection
    )

    if safe_exec_dialog(dialog) == DialogAccepted:
        selected = dialog.get_selected_students()
        save_selected_students_for_deck(deck_url, selected)
        return selected

    return None


def filter_questions_by_selected_students(
    questions: List[Dict], selected_students: Set[str]
) -> List[Dict]:
    """
    Filtra quest√µes baseado nos alunos selecionados.
    NOVA VERS√ÉO: Usa normaliza√ß√£o consistente de nomes.

    NOVO: Se sync_missing_students_notes estiver ativado, inclui quest√µes com ALUNOS vazio
    para sincroniza√ß√£o no deck [MISSING A.]

    Args:
        questions: Lista de quest√µes do deck remoto
        selected_students: Conjunto de alunos selecionados (j√° normalizados)

    Returns:
        List[Dict]: Lista filtrada de quest√µes
    """
    if not selected_students:
        return []

    # Verificar se deve incluir notas sem alunos espec√≠ficos
    from .config_manager import is_sync_missing_students_notes

    include_missing_students = is_sync_missing_students_notes()

    filtered_questions = []

    print("üîç FILTRO: Iniciando filtro de quest√µes...")
    print(f"  ‚Ä¢ Total de quest√µes: {len(questions)}")
    print(f"  ‚Ä¢ Alunos selecionados (norm): {sorted(selected_students)}")
    print(f"  ‚Ä¢ Incluir [MISSING A.]: {include_missing_students}")

    for i, question in enumerate(questions):
        fields = question.get("fields", {})
        alunos_field = fields.get(cols.ALUNOS, "").strip()

        if not alunos_field:
            # NOVO: Se funcionalidade [MISSING A.] estiver ativa, incluir nota
            if include_missing_students:
                filtered_questions.append(question)
                print(f"  üìù Quest√£o {i+1}: SEM aluno ‚Üí inclu√≠da ([MISSING A.] ativo)")
            else:
                print(
                    f"  ‚ùå Quest√£o {i+1}: SEM aluno ‚Üí ignorada ([MISSING A.] inativo)"
                )
            continue

        # Verificar se algum dos alunos selecionados est√° na lista de alunos da quest√£o
        question_students = set()
        alunos_list = re.split(r"[,;|]", alunos_field)
        for aluno in alunos_list:
            aluno = aluno.strip()
            if aluno:
                # Adicionar nome do estudante (case-sensitive)
                question_students.add(aluno)

        # DEBUG: Mostrar compara√ß√£o
        print(f"  üìù Quest√£o {i+1}: '{alunos_field}' ‚Üí {sorted(question_students)}")

        # Se h√° interse√ß√£o entre alunos da quest√£o e alunos selecionados (case-sensitive)
        intersection = question_students.intersection(selected_students)
        if intersection:
            filtered_questions.append(question)
            print(f"  ‚úÖ Quest√£o {i+1}: INCLU√çDA (match: {sorted(intersection)})")
        else:
            print(f"  ‚ùå Quest√£o {i+1}: IGNORADA (sem match)")

    print(
        f"üéØ FILTRO: {len(filtered_questions)}/{len(questions)} quest√µes selecionadas"
    )
    return filtered_questions


def get_student_subdeck_name(main_deck_name: str, student: str, fields: Dict) -> str:
    """
    Gera o nome do subdeck para um aluno espec√≠fico.

    A estrutura ser√°: "deck raiz::deck remoto::aluno::importancia::topico::subtopico::conceito"

    Args:
        main_deck_name: Nome do deck principal
        student: Nome do aluno
        fields: Campos da nota com IMPORTANCIA, TOPICO, SUBTOPICO e CONCEITO

    Returns:
        str: Nome completo do subdeck do aluno
    """
    from .templates_and_definitions import DEFAULT_CONCEPT
    from .templates_and_definitions import DEFAULT_IMPORTANCE
    from .templates_and_definitions import DEFAULT_SUBTOPIC
    from .templates_and_definitions import DEFAULT_TOPIC

    # Obter valores dos campos, usando valores padr√£o se estiverem vazios
    importancia = fields.get(cols.IMPORTANCIA, "").strip() or DEFAULT_IMPORTANCE
    topico = fields.get(cols.TOPICO, "").strip() or DEFAULT_TOPIC
    subtopico = fields.get(cols.SUBTOPICO, "").strip() or DEFAULT_SUBTOPIC
    conceito = fields.get(cols.CONCEITO, "").strip() or DEFAULT_CONCEPT

    # Criar hierarquia completa incluindo o aluno
    return (
        f"{main_deck_name}::{student}::{importancia}::{topico}::{subtopico}::{conceito}"
    )


def get_missing_students_subdeck_name(main_deck_name: str, fields: Dict) -> str:
    """
    Gera o nome do subdeck para notas sem alunos espec√≠ficos ([MISSING A.]).

    A estrutura ser√°: "deck raiz::deck remoto::[MISSING A.]::importancia::topico::subtopico::conceito"

    Args:
        main_deck_name: Nome do deck principal
        fields: Campos da nota com IMPORTANCIA, TOPICO, SUBTOPICO e CONCEITO

    Returns:
        str: Nome completo do subdeck [MISSING A.]
    """
    from .templates_and_definitions import DEFAULT_CONCEPT
    from .templates_and_definitions import DEFAULT_IMPORTANCE
    from .templates_and_definitions import DEFAULT_SUBTOPIC
    from .templates_and_definitions import DEFAULT_TOPIC

    # Obter valores dos campos, usando valores padr√£o se estiverem vazios
    importancia = fields.get(cols.IMPORTANCIA, "").strip() or DEFAULT_IMPORTANCE
    topico = fields.get(cols.TOPICO, "").strip() or DEFAULT_TOPIC
    subtopico = fields.get(cols.SUBTOPICO, "").strip() or DEFAULT_SUBTOPIC
    conceito = fields.get(cols.CONCEITO, "").strip() or DEFAULT_CONCEPT

    # Criar hierarquia completa com [MISSING A.] como "aluno"
    return f"{main_deck_name}::[MISSING A.]::{importancia}::{topico}::{subtopico}::{conceito}"


def get_students_from_question(fields: Dict) -> Set[str]:
    """
    Extrai todos os alunos de uma quest√£o espec√≠fica.

    Args:
        fields: Campos da quest√£o

    Returns:
        Set[str]: Conjunto de alunos desta quest√£o
    """
    students = set()
    alunos_field = fields.get(cols.ALUNOS, "").strip()

    if alunos_field:
        alunos_list = re.split(r"[,;|]", alunos_field)
        for aluno in alunos_list:
            aluno = aluno.strip()
            if aluno:
                students.add(aluno)

    return students


def remove_notes_for_unselected_students(
    col,
    main_deck_name: str,
    selected_students: Set[str],
    all_students_in_sheet: Set[str],
) -> int:
    """
    Remove notas de alunos que n√£o est√£o mais selecionados.

    Args:
        col: Cole√ß√£o do Anki
        main_deck_name: Nome do deck principal
        selected_students: Alunos selecionados
        all_students_in_sheet: Todos os alunos presentes na planilha

    Returns:
        int: N√∫mero de notas removidas
    """
    removed_count = 0

    if not mw or not hasattr(mw, "col") or not mw.col:
        return removed_count

    # Encontrar alunos que devem ter suas notas removidas
    unselected_students = all_students_in_sheet - selected_students

    if not unselected_students:
        return removed_count

    # Para cada aluno n√£o selecionado, encontrar e remover suas notas
    for student in unselected_students:
        # Buscar subdecks do aluno
        student_deck_pattern = f"{main_deck_name}::{student}::"

        # Encontrar todos os decks que come√ßam com este padr√£o
        all_decks = mw.col.decks.all_names_and_ids()
        student_decks = [
            d for d in all_decks if d.name.startswith(student_deck_pattern)
        ]

        for deck in student_decks:
            # Encontrar todas as notas neste deck
            note_ids = mw.col.find_notes(f'deck:"{deck.name}"')

            for note_id in note_ids:
                try:
                    mw.col.remove_notes([note_id])
                    removed_count += 1
                except Exception as e:
                    print(f"Erro ao remover nota {note_id} do deck {deck.name}: {e}")

    return removed_count


def _convert_to_tsv_export_url(url: str) -> str:
    """
    Converte uma URL do Google Sheets para formato de export TSV.
    
    Args:
        url (str): URL original do Google Sheets
        
    Returns:
        str: URL formatada para export TSV
    """
    try:
        # Se j√° √© uma URL de export TSV, retornar como est√°
        if "export?format=tsv" in url:
            print(f"‚úÖ DEBUG TSV: URL j√° est√° em formato export: {url}")
            return url
        
        # Usar a fun√ß√£o centralizada de convers√£o do utils.py
        from .utils import convert_edit_url_to_tsv
        
        try:
            tsv_url = convert_edit_url_to_tsv(url)
            print(f"üîÑ DEBUG TSV: URL convertida para export: {tsv_url}")
            return tsv_url
        except ValueError as ve:
            print(f"‚ö†Ô∏è DEBUG TSV: Erro na convers√£o usando convert_edit_url_to_tsv: {ve}")
            # Fallback para m√©todo anterior se a URL n√£o for uma URL de edi√ß√£o padr√£o
            return _fallback_url_conversion(url)
            
    except Exception as e:
        print(f"‚ùå DEBUG TSV: Erro ao converter URL: {e}")
        return url


def _fallback_url_conversion(url: str) -> str:
    """
    M√©todo de fallback para convers√£o de URLs n√£o-padr√£o.
    
    Args:
        url (str): URL original do Google Sheets
        
    Returns:
        str: URL formatada para export TSV ou URL original se falhar
    """
    try:
        import re
        
        # Padr√µes comuns de URLs do Google Sheets
        patterns = [
            r'/spreadsheets/d/([a-zA-Z0-9-_]+)',  # URL padr√£o
            r'[?&]id=([a-zA-Z0-9-_]+)',           # URL com par√¢metro id
        ]
        
        sheet_id = None
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                sheet_id = match.group(1)
                break
        
        if sheet_id:
            # Construir URL de export TSV
            tsv_url = f"https://docs.google.com/spreadsheets/d/{sheet_id}/export?format=tsv"
            print(f"üîÑ DEBUG TSV: URL convertida via fallback: {tsv_url}")
            return tsv_url
        else:
            print(f"‚ö†Ô∏è DEBUG TSV: N√£o foi poss√≠vel extrair ID da URL: {url}")
            return url
            
    except Exception as e:
        print(f"‚ùå DEBUG TSV: Erro no fallback de convers√£o: {e}")
        return url


def discover_students_from_tsv_url(url: str) -> Set[str]:
    """
    Descobre alunos √∫nicos de uma URL de TSV do Google Sheets.

    Args:
        url (str): URL do TSV do Google Sheets

    Returns:
        Set[str]: Conjunto de nomes de alunos √∫nicos encontrados
    """
    try:
        print(f"üîç DEBUG TSV: Iniciando descoberta de alunos para URL: {url}")
        
        # Primeiro, validar e converter a URL usando a fun√ß√£o centralizada
        from .utils import validate_url
        
        try:
            tsv_url = validate_url(url)
            print(f"‚úÖ DEBUG TSV: URL validada e convertida: {tsv_url}")
        except ValueError as ve:
            print(f"‚ùå DEBUG TSV: Erro na valida√ß√£o da URL: {ve}")
            # Fallback para o m√©todo anterior se a valida√ß√£o falhar
            tsv_url = _convert_to_tsv_export_url(url)
            print(f"üîÑ DEBUG TSV: Usando fallback, URL convertida: {tsv_url}")

        print(f"üåê DEBUG TSV: Fazendo download de {tsv_url}")

        # Imports necess√°rios
        try:
            import csv
            import urllib.request
            from io import StringIO
        except ImportError as e:
            print(f"‚ùå Erro ao importar m√≥dulos necess√°rios: {e}")
            return set()

        # Fazer download dos dados TSV com headers apropriados
        headers = {
            "User-Agent": "Mozilla/5.0 (Sheets2Anki) AnkiAddon"
        }
        request = urllib.request.Request(tsv_url, headers=headers)
        
        with urllib.request.urlopen(request, timeout=30) as response:
            data = response.read().decode("utf-8")

        print(f"üìÑ DEBUG TSV: Downloaded {len(data)} characters")
        print(f"üîç DEBUG TSV: First 200 chars: {repr(data[:200])}")

        # Parse CSV/TSV
        csv_reader = csv.DictReader(StringIO(data), delimiter="\t")

        students = set()
        row_count = 0

        # Verificar cabe√ßalhos primeiro
        fieldnames = csv_reader.fieldnames
        print(f"üìã DEBUG TSV: Fieldnames encontrados: {fieldnames}")
        print(f"üéØ DEBUG TSV: Procurando por coluna '{cols.ALUNOS}'")

        if not fieldnames or cols.ALUNOS not in fieldnames:
            print(f"‚ö†Ô∏è DEBUG TSV: Coluna '{cols.ALUNOS}' n√£o encontrada nos cabe√ßalhos")
            available_cols = [col for col in fieldnames if col] if fieldnames else []
            print(f"üìù DEBUG TSV: Colunas dispon√≠veis: {available_cols}")
            return set()

        # Procurar pela coluna ALUNOS
        for row in csv_reader:
            row_count += 1

            if row_count <= 3:  # Debug das primeiras 3 linhas
                print(f"üìä DEBUG TSV: Linha {row_count}: {dict(row)}")

            # Verificar se a coluna ALUNOS existe e tem conte√∫do
            if cols.ALUNOS in row and row[cols.ALUNOS]:
                # Extrair alunos (podem estar separados por v√≠rgula)
                alunos_str = row[cols.ALUNOS].strip()
                if alunos_str:
                    print(
                        f"üë• DEBUG TSV: Linha {row_count} - Alunos encontrados: '{alunos_str}'"
                    )
                    # Split por v√≠rgula e limpar espa√ßos
                    for aluno in alunos_str.split(","):
                        aluno = aluno.strip()
                        if aluno:
                            students.add(aluno)
                            print(f"‚úÖ DEBUG TSV: Adicionado aluno: '{aluno}'")

        print(f"üìä DEBUG TSV: Processadas {row_count} linhas")
        print(f"üéì DEBUG TSV: Total de estudantes √∫nicos encontrados: {len(students)}")
        print(f"üìù DEBUG TSV: Lista final: {sorted(students)}")

        return students

    except urllib.error.HTTPError as http_err:
        if http_err.code == 400:
            print(f"‚ùå DEBUG TSV: Erro HTTP 400 - A planilha n√£o est√° acess√≠vel publicamente")
            print(f"üí° SOLU√á√ÉO: Configurar compartilhamento p√∫blico da planilha:")
            print(f"   1. Abra a planilha no Google Sheets")
            print(f"   2. Clique em 'Compartilhar'")
            print(f"   3. Mude o acesso para 'Qualquer pessoa com o link'")
            print(f"   4. Defina a permiss√£o como 'Visualizador'")
        elif http_err.code == 404:
            print(f"‚ùå DEBUG TSV: Erro HTTP 404 - Planilha n√£o encontrada")
            print(f"üí° VERIFICAR: URL da planilha est√° correta?")
        else:
            print(f"‚ùå DEBUG TSV: Erro HTTP {http_err.code}: {http_err.reason}")
        
        print(f"üîç DEBUG TSV: Traceback HTTP Error:")
        import traceback
        traceback.print_exc()
        return set()
        
    except urllib.error.URLError as url_err:
        print(f"‚ùå DEBUG TSV: Erro de conectividade: {url_err.reason}")
        print(f"üí° VERIFICAR: Conex√£o com internet ativa?")
        print(f"üîç DEBUG TSV: Traceback URL Error:")
        import traceback
        traceback.print_exc()
        return set()
        
    except Exception as e:
        print(f"‚ùå Erro ao descobrir alunos da URL {url}: {e}")
        import traceback

        print("üîç DEBUG TSV: Traceback completo:")
        traceback.print_exc()
        return set()


def cleanup_disabled_students_data(
    disabled_students: Set[str], deck_names: List[str]
) -> Dict[str, int]:
    """
    Remove todos os dados de alunos desabilitados: notas, cards, note types e decks.

    L√ìGICA REFATORADA para funcionar com IDs √∫nicos {student}_{id}:
    - Busca notas por ID √∫nico usando o formato {student}_{id}
    - Remove notas baseado no campo ID das notas, n√£o mais por localiza√ß√£o em deck
    - Remove decks vazios ap√≥s remo√ß√£o das notas
    - Remove note types n√£o utilizados

    Args:
        disabled_students (Set[str]): Conjunto de alunos que foram desabilitados
        deck_names (List[str]): Lista de nomes de decks remotos para filtrar opera√ß√µes

    Returns:
        Dict[str, int]: Estat√≠sticas de remo√ß√£o {
            'notes_removed': int,
            'decks_removed': int,
            'note_types_removed': int
        }
    """
    if not disabled_students or not mw or not hasattr(mw, "col") or not mw.col:
        return {"notes_removed": 0, "decks_removed": 0, "note_types_removed": 0}

    print(
        f"üóëÔ∏è CLEANUP: Iniciando limpeza de dados para alunos: {sorted(disabled_students)}"
    )

    stats = {"notes_removed": 0, "decks_removed": 0, "note_types_removed": 0}
    col = mw.col

    try:
        # 1. Primeiro, encontrar e remover todas as notas dos alunos desabilitados
        notes_to_remove = []

        for student in disabled_students:
            print(f"üßπ CLEANUP: Processando aluno '{student}'...")

            # Buscar notas por ID √∫nico no formato {student}_{id} ou [MISSING A.]_{id}
            # Usar busca por campo ID que cont√©m o student_note_id
            student_pattern = f"{student}_*"

            # Buscar todas as notas no Anki que tenham esse aluno no campo ID
            # Como n√£o podemos fazer busca direta por campo personalizado, vamos iterar
            all_note_ids = col.find_notes("*")  # Todas as notas - usar wildcard
            student_note_ids = []

            for note_id in all_note_ids:
                try:
                    note = col.get_note(note_id)
                    # Verificar se a nota tem o campo ID e se corresponde ao aluno
                    if "ID" in note.keys():
                        note_unique_id = note["ID"].strip()
                        # Verificar se o ID da nota come√ßa com "{student}_"
                        if note_unique_id.startswith(f"{student}_"):
                            student_note_ids.append(note_id)
                            print(
                                f"   ÔøΩ Encontrada nota do aluno '{student}': {note_unique_id}"
                            )
                except:
                    continue

            notes_to_remove.extend(student_note_ids)
            print(
                f"   üìä Total de notas encontradas para '{student}': {len(student_note_ids)}"
            )

        # 2. Remover todas as notas encontradas
        if notes_to_remove:
            print(f"üóëÔ∏è CLEANUP: Removendo {len(notes_to_remove)} notas...")
            col.remove_notes(notes_to_remove)
            stats["notes_removed"] = len(notes_to_remove)
            print(f"‚úÖ CLEANUP: {len(notes_to_remove)} notas removidas")

        # 3. Encontrar e remover decks vazios dos alunos desabilitados
        for student in disabled_students:
            for deck_name in deck_names:
                # Padr√£o de deck do aluno: "Sheets2Anki::{deck_name}::{student}::"
                student_deck_pattern = f"Sheets2Anki::{deck_name}::{student}::"

                # Encontrar todos os decks que come√ßam com este padr√£o
                all_decks = col.decks.all_names_and_ids()
                matching_decks = [
                    d for d in all_decks if d.name.startswith(student_deck_pattern)
                ]

                for deck in matching_decks:
                    try:
                        # Verificar se o deck est√° vazio
                        remaining_notes = col.find_notes(f'deck:"{deck.name}"')
                        if not remaining_notes:
                            # Deck vazio, pode remover
                            from anki.decks import DeckId

                            deck_id = DeckId(deck.id)
                            col.decks.remove([deck_id])
                            stats["decks_removed"] += 1
                            print(f"   üóëÔ∏è Deck vazio removido: '{deck.name}'")
                        else:
                            print(
                                f"   üìÅ Deck '{deck.name}' ainda tem {len(remaining_notes)} notas, mantendo"
                            )
                    except Exception as e:
                        print(f"   ‚ùå Erro ao processar deck '{deck.name}': {e}")
                        continue

            # Remover note types do aluno
            removed_note_types = _remove_student_note_types(student, deck_names)
            stats["note_types_removed"] += removed_note_types

        # NOVO: Atualizar meta.json ap√≥s limpeza para remover refer√™ncias de note types deletados
        _update_meta_after_cleanup(disabled_students, deck_names)
        
        # NOVO: Remover alunos do hist√≥rico de sincroniza√ß√£o ap√≥s limpeza bem-sucedida
        from .config_manager import remove_student_from_sync_history
        for student in disabled_students:
            remove_student_from_sync_history(student)
        print(f"üìù CLEANUP: {len(disabled_students)} alunos removidos do hist√≥rico de sincroniza√ß√£o")

        # Salvar mudan√ßas
        col.save()

        print(f"‚úÖ CLEANUP: Conclu√≠do! Stats: {stats}")
        return stats

    except Exception as e:
        print(f"‚ùå CLEANUP: Erro durante limpeza: {e}")
        import traceback

        traceback.print_exc()
        return stats


def _remove_student_note_types(student: str, deck_names: List[str]) -> int:
    """
    Remove note types espec√≠ficos de um aluno.
    
    VERS√ÉO CORRIGIDA COM DEBUG MELHORADO:
    - Verifica todos os note types no Anki, n√£o apenas os baseados em deck_names
    - Remove note types √≥rf√£os que podem existir por configura√ß√µes antigas
    - Detecta padr√µes variados de nomenclatura
    - Adiciona logs detalhados para debug
    - Usa sistema de logging adequado do addon

    Args:
        student (str): Nome do aluno
        deck_names (List[str]): Lista de nomes de decks remotos (usado como filtro preferencial)

    Returns:
        int: N√∫mero de note types removidos
    """
    # Usar logging adequado quando poss√≠vel
    try:
        from .utils import add_debug_message
        log_func = lambda msg: add_debug_message(msg, "CLEANUP_NOTE_TYPES")
    except:
        log_func = print
    
    if not mw or not hasattr(mw, "col") or not mw.col:
        log_func(f"‚ùå Anki n√£o dispon√≠vel para remover note types do aluno '{student}'")
        return 0

    col = mw.col
    removed_count = 0

    try:
        # Obter todos os note types
        note_types = col.models.all()
        log_func(f"üîç Verificando {len(note_types)} note types para aluno '{student}'")

        student_note_types_found = []
        
        for note_type in note_types:
            note_type_name = note_type.get("name", "")
            note_type_id = note_type.get("id")

            if not note_type_id:
                continue

            should_remove = False
            match_reason = ""

            # M√âTODO 1: Verificar padr√µes baseados nos deck_names fornecidos
            for deck_name in deck_names:
                student_pattern_basic = f"Sheets2Anki - {deck_name} - {student} - Basic"
                student_pattern_cloze = f"Sheets2Anki - {deck_name} - {student} - Cloze"

                if note_type_name == student_pattern_basic or note_type_name == student_pattern_cloze:
                    should_remove = True
                    match_reason = f"deck pattern for '{student}'"
                    break

            # M√âTODO 2: Verificar padr√£o geral para note types √≥rf√£os (fallback robusto)
            if not should_remove and note_type_name.startswith("Sheets2Anki - "):
                # Formato geral: "Sheets2Anki - {qualquer_deck} - {student} - {Basic|Cloze}"
                parts = note_type_name.split(" - ")
                if len(parts) >= 4:
                    # O aluno est√° na terceira parte (√≠ndice 2)
                    note_student = parts[2]
                    note_type_suffix = parts[-1]  # Basic ou Cloze
                    
                    if (note_student == student and 
                        note_type_suffix in ["Basic", "Cloze"]):
                        should_remove = True
                        match_reason = f"orphaned note type for student '{student}'"

            if should_remove:
                student_note_types_found.append((note_type_name, note_type_id, match_reason))

        log_func(f"üéØ Encontrados {len(student_note_types_found)} note types para aluno '{student}':")
        for nt_name, nt_id, reason in student_note_types_found:
            log_func(f"   ‚Ä¢ '{nt_name}' (ID: {nt_id}) - {reason}")

        # Tentar remover os note types encontrados
        for note_type_name, note_type_id, match_reason in student_note_types_found:
            try:
                # Verificar se o note type est√° em uso
                use_count = col.models.useCount(note_type_id)
                
                if use_count > 0:
                    log_func(f"‚ö†Ô∏è Note type '{note_type_name}' ainda tem {use_count} notas, pulando remo√ß√£o")
                    continue

                # Note type n√£o est√° em uso, pode remover
                log_func(f"üóëÔ∏è REMOVENDO note type '{note_type_name}' (ID: {note_type_id})...")
                
                from anki.models import NotetypeId
                col.models.remove(NotetypeId(note_type_id))
                removed_count += 1
                log_func(f"‚úÖ Note type '{note_type_name}' removido com sucesso")

            except Exception as e:
                log_func(f"‚ùå Erro ao remover note type '{note_type_name}': {e}")
                import traceback
                traceback.print_exc()
                continue

        if removed_count == 0 and len(student_note_types_found) > 0:
            log_func(f"‚ö†Ô∏è ATEN√á√ÉO: {len(student_note_types_found)} note types encontrados mas nenhum foi removido")
        elif removed_count > 0:
            log_func(f"‚úÖ SUCESSO: {removed_count} note types removidos para aluno '{student}'")
        else:
            log_func(f"‚ÑπÔ∏è Nenhum note type encontrado para aluno '{student}'")

        return removed_count

    except Exception as e:
        log_func(f"‚ùå Erro ao remover note types do aluno '{student}': {e}")
        import traceback
        traceback.print_exc()
        return 0


def _update_meta_after_cleanup(
    disabled_students: Set[str], deck_names: List[str]
) -> None:
    """
    Atualiza o meta.json removendo refer√™ncias de note types que foram deletados durante cleanup.

    Args:
        disabled_students (Set[str]): Conjunto de alunos que foram desabilitados
        deck_names (List[str]): Lista de nomes de decks remotos
    """
    # Usar logging adequado quando poss√≠vel
    try:
        from .utils import add_debug_message
        log_func = lambda msg: add_debug_message(msg, "CLEANUP_META")
    except:
        log_func = print
        
    try:
        from .config_manager import get_meta
        from .config_manager import save_meta

        log_func(
            f"üìù META UPDATE: Atualizando meta.json ap√≥s limpeza de {len(disabled_students)} alunos"
        )

        meta = get_meta()
        updates_made = False

        # Para cada deck configurado
        for deck_info in meta.get("decks", {}).values():
            deck_name = deck_info.get("remote_deck_name", "")
            if deck_name in deck_names:
                note_types_dict = deck_info.get("note_types", {})
                note_types_to_remove = []

                # Encontrar note types dos alunos desabilitados
                for note_type_id, note_type_name in note_types_dict.items():
                    for student in disabled_students:
                        # Formato: "Sheets2Anki - {remote_deck_name} - {student} - {Basic|Cloze}"
                        student_pattern_basic = (
                            f"Sheets2Anki - {deck_name} - {student} - Basic"
                        )
                        student_pattern_cloze = (
                            f"Sheets2Anki - {deck_name} - {student} - Cloze"
                        )

                        if (
                            note_type_name == student_pattern_basic
                            or note_type_name == student_pattern_cloze
                        ):
                            note_types_to_remove.append(note_type_id)
                            log_func(
                                f"üóëÔ∏è META: Removendo refer√™ncia do note type '{note_type_name}' (ID: {note_type_id})"
                            )

                # Remover os note types encontrados
                for note_type_id in note_types_to_remove:
                    if note_type_id in note_types_dict:
                        del note_types_dict[note_type_id]
                        updates_made = True

        # Salvar meta.json atualizado se houve mudan√ßas
        if updates_made:
            save_meta(meta)
            log_func(
                f"‚úÖ META UPDATE: meta.json atualizado com {len([nt for deck in meta.get('decks', {}).values() for nt in deck.get('note_types', {}).keys()])} note types restantes"
            )
        else:
            log_func("‚ÑπÔ∏è META UPDATE: Nenhuma atualiza√ß√£o necess√°ria no meta.json")

    except Exception as e:
        log_func(f"‚ùå META UPDATE: Erro ao atualizar meta.json ap√≥s cleanup: {e}")
        import traceback

        traceback.print_exc()


def _update_meta_after_missing_cleanup(deck_names: List[str]) -> None:
    """
    Atualiza o meta.json removendo refer√™ncias de note types [MISSING A.] que foram deletados.

    Args:
        deck_names (List[str]): Lista de nomes de decks remotos
    """
    # Usar logging adequado quando poss√≠vel
    try:
        from .utils import add_debug_message
        log_func = lambda msg: add_debug_message(msg, "CLEANUP_MISSING_META")
    except:
        log_func = print
        
    try:
        from .config_manager import get_meta
        from .config_manager import save_meta

        log_func(
            f"üìù META UPDATE: Atualizando meta.json ap√≥s limpeza [MISSING A.] para {len(deck_names)} decks"
        )

        meta = get_meta()
        updates_made = False

        # Para cada deck configurado
        for deck_info in meta.get("decks", {}).values():
            deck_name = deck_info.get("remote_deck_name", "")
            if deck_name in deck_names:
                note_types_dict = deck_info.get("note_types", {})
                note_types_to_remove = []

                # Encontrar note types [MISSING A.]
                for note_type_id, note_type_name in note_types_dict.items():
                    # Formato: "Sheets2Anki - {remote_deck_name} - [MISSING A.] - {Basic|Cloze}"
                    missing_pattern_basic = (
                        f"Sheets2Anki - {deck_name} - [MISSING A.] - Basic"
                    )
                    missing_pattern_cloze = (
                        f"Sheets2Anki - {deck_name} - [MISSING A.] - Cloze"
                    )

                    if (
                        note_type_name == missing_pattern_basic
                        or note_type_name == missing_pattern_cloze
                    ):
                        note_types_to_remove.append(note_type_id)
                        log_func(
                            f"üóëÔ∏è META: Removendo refer√™ncia do note type '[MISSING A.]': '{note_type_name}' (ID: {note_type_id})"
                        )

                # Remover os note types encontrados
                for note_type_id in note_types_to_remove:
                    if note_type_id in note_types_dict:
                        del note_types_dict[note_type_id]
                        updates_made = True

        # Salvar meta.json atualizado se houve mudan√ßas
        if updates_made:
            save_meta(meta)
            log_func("‚úÖ META UPDATE: meta.json atualizado ap√≥s limpeza [MISSING A.]")
        else:
            log_func(
                "‚ÑπÔ∏è META UPDATE: Nenhuma refer√™ncia [MISSING A.] encontrada no meta.json"
            )

    except Exception as e:
        log_func(
            f"‚ùå META UPDATE: Erro ao atualizar meta.json ap√≥s limpeza [MISSING A.]: {e}"
        )
        import traceback

        traceback.print_exc()


def get_disabled_students_for_cleanup(
    current_enabled: Set[str], previous_enabled: Set[str]
) -> Set[str]:
    """
    Identifica alunos que foram removidos da lista de habilitados e precisam ter dados limpos.
    
    VERS√ÉO CORRIGIDA PARA L√ìGICA ADEQUADA:
    - Considera apenas alunos que foram SINCRONIZADOS pelo menos uma vez
    - Um aluno s√≥ pode ter dados para limpeza se j√° teve dados criados anteriormente
    - Alunos que est√£o em available_students mas nunca foram sincronizados N√ÉO devem ser limpos
    - Detecta note types existentes no Anki como fonte secund√°ria
    
    NOTA: [MISSING A.] n√£o √© considerado um "aluno" para prop√≥sitos de limpeza.
    Sua presen√ßa depende da configura√ß√£o sync_missing_students_notes, n√£o da lista de alunos habilitados.

    Args:
        current_enabled (Set[str]): Alunos atualmente habilitados
        previous_enabled (Set[str]): Alunos habilitados anteriormente (pode ser usado como fonte adicional)

    Returns:
        Set[str]: Alunos que foram desabilitados e precisam ter dados removidos
    """
    # Usar logging adequado quando poss√≠vel
    try:
        from .utils import add_debug_message
        log_func = lambda msg: add_debug_message(msg, "CLEANUP")
    except:
        log_func = print
    
    log_func("üîç CLEANUP: Identificando alunos desabilitados para limpeza...")
    
    # FONTE PRINCIPAL: Apenas alunos que foram sincronizados pelo menos uma vez
    from .config_manager import get_students_with_sync_history
    historically_synced_students = get_students_with_sync_history()
    log_func(f"üìö Alunos que j√° foram sincronizados: {sorted(historically_synced_students)}")
    
    # FONTE ADICIONAL: Note types existentes no Anki (para casos de inconsist√™ncia)
    anki_detected_students = set()
    if hasattr(mw, "col") and mw.col:
        try:
            note_types = mw.col.models.all()
            for note_type in note_types:
                note_type_name = note_type.get("name", "")
                # Formato: "Sheets2Anki - {remote_deck_name} - {student} - {Basic|Cloze}"
                if note_type_name.startswith("Sheets2Anki - ") and " - " in note_type_name:
                    parts = note_type_name.split(" - ")
                    if len(parts) >= 4:
                        # O aluno est√° na terceira parte (√≠ndice 2)
                        student_name = parts[2]
                        if student_name and student_name != "[MISSING A.]":
                            anki_detected_students.add(student_name)
            
            all_known_students.update(anki_detected_students)
            log_func(f"   ÔøΩ Alunos encontrados no Anki: {sorted(anki_detected_students)}")
        except Exception as e:
            log_func(f"   ‚ö†Ô∏è Erro ao verificar note types no Anki: {e}")
    
    # FONTE 4: Previous enabled como fonte adicional (se fornecido)
    if previous_enabled:
        all_known_students.update(previous_enabled)
    
    log_func(f"   üìà Total de alunos hist√≥ricos: {sorted(all_known_students)}")
    
    # Remover [MISSING A.] da compara√ß√£o, pois n√£o √© um "aluno real"
    current_real_students = {s for s in current_enabled if s != "[MISSING A.]"}
    all_known_real_students = {s for s in all_known_students if s != "[MISSING A.]"}

    log_func(f"   ‚úÖ Alunos reais atualmente habilitados: {sorted(current_real_students)}")
    log_func(f"   üìñ Alunos reais conhecidos: {sorted(all_known_real_students)}")

    # DETEC√á√ÉO PRINCIPAL: Alunos que tinham dados mas n√£o est√£o mais habilitados
    disabled_students = students_with_data_real - current_real_students

    if disabled_students:
        log_func(f"üéØ CLEANUP: Detectados alunos para limpeza: {sorted(disabled_students)}")
        log_func(f"   ‚Ä¢ Atualmente habilitados: {sorted(current_real_students)}")
        log_func(f"   ‚Ä¢ Com dados criados: {sorted(students_with_data_real)}")
        log_func(f"   ‚Ä¢ Alunos a remover: {sorted(disabled_students)}")
    else:
        log_func("‚úÖ CLEANUP: Nenhum aluno foi desabilitado")

    log_func("üîç CLEANUP: [MISSING A.] exclu√≠do da compara√ß√£o (n√£o √© aluno real)")

    return disabled_students


def show_cleanup_confirmation_dialog(disabled_students: Set[str]) -> bool:
    """
    Mostra um di√°logo de confirma√ß√£o antes de remover dados de alunos desabilitados.

    Args:
        disabled_students (Set[str]): Conjunto de alunos que ter√£o dados removidos

    Returns:
        bool: True se o usu√°rio confirmou a remo√ß√£o, False caso contr√°rio
    """
    from .compat import MessageBox_No
    from .compat import MessageBox_Warning
    from .compat import MessageBox_Yes
    from .compat import QMessageBox

    if not disabled_students:
        return False

    students_list = "\n".join([f"‚Ä¢ {student}" for student in sorted(disabled_students)])

    message = (
        f"‚ö†Ô∏è ATEN√á√ÉO: REMO√á√ÉO PERMANENTE DE DADOS ‚ö†Ô∏è\n\n"
        f"Os seguintes alunos foram removidos da lista de sincroniza√ß√£o:\n\n"
        f"{students_list}\n\n"
        f"üóëÔ∏è DADOS QUE SER√ÉO DELETADOS PERMANENTEMENTE:\n"
        f"‚Ä¢ Todas as notas dos alunos\n"
        f"‚Ä¢ Todos os cards dos alunos\n"
        f"‚Ä¢ Todos os decks dos alunos\n"
        f"‚Ä¢ Todos os note types dos alunos\n\n"
        f"‚ùå ESTA A√á√ÉO √â IRREVERS√çVEL!\n\n"
        f"Deseja continuar com a remo√ß√£o dos dados?"
    )

    # Criar MessageBox customizado
    msg_box = QMessageBox()
    msg_box.setIcon(MessageBox_Warning)
    msg_box.setWindowTitle("Confirmar Remo√ß√£o Permanente de Dados")
    msg_box.setText(message)
    msg_box.setStandardButtons(MessageBox_Yes | MessageBox_No)
    msg_box.setDefaultButton(MessageBox_No)  # Default √© NOT remover

    # Customizar bot√µes
    yes_btn = msg_box.button(MessageBox_Yes)
    no_btn = msg_box.button(MessageBox_No)

    if yes_btn:
        yes_btn.setText("üóëÔ∏è SIM, DELETAR DADOS")
        yes_btn.setStyleSheet(
            "QPushButton { background-color: #d73027; color: white; font-weight: bold; }"
        )

    if no_btn:
        no_btn.setText("üõ°Ô∏è N√ÉO, MANTER DADOS")
        no_btn.setStyleSheet(
            "QPushButton { background-color: #4575b4; color: white; font-weight: bold; }"
        )

    # Executar di√°logo
    from .compat import safe_exec_dialog

    result = safe_exec_dialog(msg_box)

    confirmed = result == MessageBox_Yes

    if confirmed:
        print(
            f"‚ö†Ô∏è CLEANUP: Usu√°rio confirmou remo√ß√£o de dados de {len(disabled_students)} alunos"
        )
    else:
        print("üõ°Ô∏è CLEANUP: Usu√°rio cancelou remo√ß√£o de dados")

    return confirmed


def cleanup_missing_students_data(deck_names: List[str]) -> Dict[str, int]:
    """
    Remove todos os dados de notas "[MISSING A.]" quando a funcionalidade for desativada.
    
    VERS√ÉO CORRIGIDA:
    - Detecta note types [MISSING A.] usando m√∫ltiplos padr√µes
    - Busca por note types √≥rf√£os mesmo que o deck_name n√£o corresponda exatamente
    - Remove dados de forma mais robusta

    Args:
        deck_names (List[str]): Lista de nomes de decks remotos para filtrar opera√ß√µes

    Returns:
        Dict[str, int]: Estat√≠sticas de remo√ß√£o {
            'notes_removed': int,
            'decks_removed': int,
            'note_types_removed': int
        }
    """
    if not mw or not hasattr(mw, "col") or not mw.col:
        return {"notes_removed": 0, "decks_removed": 0, "note_types_removed": 0}

    print(
        f"üóëÔ∏è CLEANUP: Iniciando limpeza de dados [MISSING A.] para decks: {deck_names}"
    )

    stats = {"notes_removed": 0, "decks_removed": 0, "note_types_removed": 0}
    col = mw.col

    try:
        # 1. Buscar e remover todas as notas com ID [MISSING A.]_{qualquer_id}
        all_note_ids = col.find_notes("*")
        missing_note_ids = []

        for note_id in all_note_ids:
            try:
                note = col.get_note(note_id)
                if "ID" in note.keys():
                    note_unique_id = note["ID"].strip()
                    if note_unique_id.startswith("[MISSING A.]_"):
                        missing_note_ids.append(note_id)
                        print(f"   üìù Encontrada nota [MISSING A.]: {note_unique_id}")
            except:
                continue

        # Remover todas as notas [MISSING A.] encontradas
        if missing_note_ids:
            print(f"üóëÔ∏è CLEANUP: Removendo {len(missing_note_ids)} notas [MISSING A.]...")
            col.remove_notes(missing_note_ids)
            stats["notes_removed"] = len(missing_note_ids)

        # 2. Remover decks [MISSING A.] (usando m√∫ltiplos padr√µes)
        all_decks = col.decks.all_names_and_ids()
        
        # Padr√µes a procurar:
        # - "Sheets2Anki::{deck_name}::[MISSING A.]::"
        # - Qualquer deck que contenha "::[MISSING A.]::"
        missing_decks_found = []
        
        for deck in all_decks:
            deck_name = deck.name
            
            # Verificar se √© um deck [MISSING A.]
            if "::[MISSING A.]::" in deck_name:
                # Verificar se corresponde a algum dos decks especificados (se fornecidos)
                if deck_names:
                    deck_matches = False
                    for remote_deck_name in deck_names:
                        expected_pattern = f"Sheets2Anki::{remote_deck_name}::[MISSING A.]::"
                        if deck_name.startswith(expected_pattern):
                            deck_matches = True
                            break
                    
                    if deck_matches:
                        missing_decks_found.append(deck)
                        print(f"   üìÅ Deck [MISSING A.] encontrado: {deck_name}")
                else:
                    # Se n√£o h√° deck_names especificados, remover qualquer deck [MISSING A.]
                    missing_decks_found.append(deck)
                    print(f"   üìÅ Deck [MISSING A.] gen√©rico encontrado: {deck_name}")

        # Remover decks [MISSING A.] vazios
        for deck in missing_decks_found:
            try:
                remaining_notes = col.find_notes(f'deck:"{deck.name}"')
                if not remaining_notes:
                    from anki.decks import DeckId
                    col.decks.remove([DeckId(deck.id)])
                    stats["decks_removed"] += 1
                    print(f"   üóëÔ∏è Deck [MISSING A.] vazio removido: '{deck.name}'")
                else:
                    print(f"   ÔøΩ Deck [MISSING A.] '{deck.name}' ainda tem {len(remaining_notes)} notas, mantendo")
            except Exception as e:
                print(f"   ‚ùå Erro ao processar deck [MISSING A.] '{deck.name}': {e}")

        # 3. Remover note types [MISSING A.] (usando detec√ß√£o robusta)
        note_types = col.models.all()
        
        for note_type in note_types:
            note_type_name = note_type.get("name", "")
            note_type_id = note_type.get("id")
            
            if not note_type_id:
                continue
            
            should_remove = False
            
            # M√âTODO 1: Verificar padr√µes baseados nos deck_names fornecidos
            if deck_names:
                for deck_name in deck_names:
                    missing_pattern_basic = f"Sheets2Anki - {deck_name} - [MISSING A.] - Basic"
                    missing_pattern_cloze = f"Sheets2Anki - {deck_name} - [MISSING A.] - Cloze"
                    
                    if note_type_name == missing_pattern_basic or note_type_name == missing_pattern_cloze:
                        should_remove = True
                        print(f"   üéØ Note type [MISSING A.] '{note_type_name}' matched deck pattern")
                        break
            
            # M√âTODO 2: Verificar padr√£o geral para note types [MISSING A.] √≥rf√£os
            if not should_remove and note_type_name.startswith("Sheets2Anki - "):
                parts = note_type_name.split(" - ")
                if len(parts) >= 4:
                    note_student = parts[2]
                    note_type_suffix = parts[-1]
                    
                    if (note_student == "[MISSING A.]" and 
                        note_type_suffix in ["Basic", "Cloze"]):
                        should_remove = True
                        print(f"   üîç Note type [MISSING A.] √≥rf√£o '{note_type_name}' found")
            
            if should_remove:
                try:
                    # Verificar se o note type est√° em uso
                    use_count = col.models.useCount(note_type_id)
                    
                    if use_count > 0:
                        print(f"   ‚ö†Ô∏è Note type [MISSING A.] '{note_type_name}' ainda tem {use_count} notas, pulando")
                        continue
                    
                    # Note type n√£o est√° em uso, pode remover
                    from anki.models import NotetypeId
                    col.models.remove(NotetypeId(note_type_id))
                    stats["note_types_removed"] += 1
                    print(f"   üóëÔ∏è Note type [MISSING A.] '{note_type_name}' removido")
                    
                except Exception as e:
                    print(f"   ‚ùå Erro ao remover note type [MISSING A.] '{note_type_name}': {e}")

        # NOVO: Atualizar meta.json ap√≥s limpeza
        _update_meta_after_missing_cleanup(deck_names)

        # Salvar mudan√ßas
        col.save()

        print(f"‚úÖ CLEANUP: Limpeza [MISSING A.] conclu√≠da - Estat√≠sticas: {stats}")
        return stats

    except Exception as e:
        print(f"‚ùå CLEANUP: Erro durante limpeza [MISSING A.]: {e}")
        import traceback
        traceback.print_exc()
        return stats


def show_missing_cleanup_confirmation_dialog() -> bool:
    """
    Mostra di√°logo de confirma√ß√£o para limpeza de dados [MISSING A.].

    Returns:
        bool: True se usu√°rio confirmou a remo√ß√£o
    """
    from .compat import MessageBox_No
    from .compat import MessageBox_Yes
    from .compat import QMessageBox

    msg_box = QMessageBox(mw)
    msg_box.setWindowTitle("‚ö†Ô∏è Confirma√ß√£o de Remo√ß√£o - Notas [MISSING A.]")
    msg_box.setIcon(QMessageBox.Icon.Warning)

    text = (
        "üóëÔ∏è REMO√á√ÉO DE NOTAS SEM ALUNOS ESPEC√çFICOS\n\n"
        "Voc√™ desativou a sincroniza√ß√£o de notas sem alunos espec√≠ficos.\n\n"
        "üìã O que ser√° removido:\n"
        "‚Ä¢ Todas as notas em subdecks [MISSING A.]\n"
        "‚Ä¢ Todos os subdecks [MISSING A.] e seus conte√∫dos\n"
        "‚Ä¢ Note types espec√≠ficos para [MISSING A.]\n\n"
        "‚ö†Ô∏è ESTA A√á√ÉO √â IRREVERS√çVEL!\n"
        "Os dados removidos n√£o podem ser recuperados.\n\n"
        "Deseja continuar com a remo√ß√£o?"
    )

    msg_box.setText(text)
    msg_box.setStandardButtons(MessageBox_Yes | MessageBox_No)
    msg_box.setDefaultButton(MessageBox_No)  # Bot√£o seguro como padr√£o

    # Customizar bot√µes
    yes_btn = msg_box.button(MessageBox_Yes)
    no_btn = msg_box.button(MessageBox_No)

    if yes_btn:
        yes_btn.setText("üóëÔ∏è SIM, DELETAR [MISSING A.]")
        yes_btn.setStyleSheet(
            "QPushButton { background-color: #d73027; color: white; font-weight: bold; }"
        )

    if no_btn:
        no_btn.setText("üõ°Ô∏è N√ÉO, MANTER DADOS")
        no_btn.setStyleSheet(
            "QPushButton { background-color: #4575b4; color: white; font-weight: bold; }"
        )

    # Executar di√°logo
    from .compat import safe_exec_dialog

    result = safe_exec_dialog(msg_box)

    confirmed = result == MessageBox_Yes

    if confirmed:
        print("‚ö†Ô∏è CLEANUP: Usu√°rio confirmou remo√ß√£o de dados [MISSING A.]")
    else:
        print("üõ°Ô∏è CLEANUP: Usu√°rio cancelou remo√ß√£o de dados [MISSING A.]")

    return confirmed
